.\" last modified 2015-06-09
.\" Dorai Sitaram
.
.\" don't load if not groff
.if !\n(.g .nx
.
.\" don't load more than once
.
.if d eval4troff:snippets .nx
.
.if !\n[.troff2page] \{\
.de eval4troff:snippets
.  \" change this to suit the Common Lisp impl
.  sy touch \\*[eval4troff:file]
.  sy if   test "$LISP" = clisp; then clisp \\*[eval4troff:file]; \
   elif test "$LISP" = clozure; then ccl -l \\*[eval4troff:file] -e '(ccl:quit)'; \
   elif test "$LISP" = cmu; then lisp -quiet -load \\*[eval4troff:file] -eval '(ext:quit)'; \
   elif test "$LISP" = ecl; then ecl -shell \\*[eval4troff:file]; \
   elif test "$LISP" = sbcl; then sbcl --noinform --load \\*[eval4troff:file] --eval '(sb-ext:quit)'; \
   elif test "$(uname -s)" = Linux -o "$(uname -s)" = SunOS; then sbcl --noinform --load \\*[eval4troff:file] --eval '(sb-ext:quit)'; \
   elif test "$(uname -s)" = Darwin; then ccl -l \\*[eval4troff:file] -e '(ccl:quit)'; \
   else clisp \\*[eval4troff:file]; \
   fi
..
.\}
.
.if '\*[AUXF]'' .ds AUXF .trofftemp
.
.nr eval4troff:already_setup 0
.
.de eval4troff:setup
.  if \\n[eval4troff:already_setup] .return
.  nr eval4troff:already_setup 1
.  nr eval4troff:count 0
.  if !\\n[.U] .return
.  ds eval4troff:file \\*[AUXF].lisp
.  eval4troff:snippets
.  open  eval4troff:port \\*[eval4troff:file]
.  write eval4troff:port (defvar *eval4troff-stdout* *standard-output*)
.  write eval4troff:port (defun eval4troff-preamble (f)
.  write eval4troff:port   (setq *standard-output*
.  write eval4troff:port     (open f :direction :output :if-exists :supersede)))
.  write eval4troff:port (defun eval4troff-postamble ()
.  write eval4troff:port   (format t "\\\\\\\\c~%")
.  write eval4troff:port   (format t ".ds eval4troff:status done~%")
.  write eval4troff:port   (close *standard-output*)
.  write eval4troff:port   (setq *standard-output* *eval4troff-stdout*))
..
.
.ds eval4troff:status try
.
.de eval
.  eo
.  de eval4troff:text endeval
..
.
.de endeval
.  ec
.  eval4troff:so_snippet
.  eval4troff:write_snippet
..
.de eval4troff:write_snippet
.  if !\\n[.U] .return
.  write  eval4troff:port (eval4troff-preamble "\\*[eval4troff:snippet_file]")
.  eo
.  writem eval4troff:port eval4troff:text
.  ec
.  write  eval4troff:port (eval4troff-postamble)
..
.
.de eval4troff:so_snippet
.  eval4troff:setup
.  nr eval4troff:count +1
.  ds eval4troff:snippet_file \\*[AUXF]_eval_\\n[eval4troff:count].tmp
.  if !'\\*[eval4troff:status]'rerun' \{\
.    nr eval4troff:systat 0
.    if \\n[.U] \{\
.      sy test -f \\*[eval4troff:snippet_file]
.      nr eval4troff:systat \\n[systat]
.    \}
.    if !\\n[eval4troff:systat] \{\
.      so \\*[eval4troff:snippet_file]
.      if '\\*[eval4troff:status]'done' .return
.    \}
.    ds eval4troff:status rerun
.    if !\\n[.troff2page] .tm Rerun groff with -U
.  \}
\[rh]eval\[lh]
..
.
.ig ##
(defrequest "eval4troff:snippets"
  (lambda ()
    (read-troff-line)
    (let ((f (concatenate 'string
                (funcall (gethash "AUXF" *string-table*))
                ".lisp")))
      (when (probe-file f) (load f)))))
.##
